// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Package linkedlist creates a UserLinkedList data structure for the User type
// generate a `IntLinkedList` linked list of `int` values
// cmd call --> genny -in linkedlist.go -out linkedlist-int.go gen "User=int"

package linkedlist

import (
	"fmt"
	"sync"

	"drawAndGuessServer/data/structure/bean"
)

// Node a single node that composes the list
type Node struct {
	content *bean.User
	next    *Node
}

// UserLinkedList the linked list of Users
type UserLinkedList struct {
	head *Node
	size int
	lock sync.RWMutex
}

// Append adds an User to the end of the linked list
func (ll *UserLinkedList) Append(t *bean.User) {
	ll.lock.Lock()
	node := Node{t, nil}
	if ll.head == nil {
		ll.head = &node
	} else {
		last := ll.head
		for {
			if last.next == nil {
				break
			}
			last = last.next
		}
		last.next = &node
	}
	ll.size++
	ll.lock.Unlock()
}

// Insert adds an User at position i
func (ll *UserLinkedList) Insert(i int, t *bean.User) error {
	ll.lock.Lock()
	defer ll.lock.Unlock()
	if i < 0 || i > ll.size {
		return fmt.Errorf("Index out of bounds")
	}
	addNode := Node{t, nil}
	if i == 0 {
		addNode.next = ll.head
		ll.head = &addNode
		return nil
	}
	node := ll.head
	j := 0
	for j < i-2 {
		j++
		node = node.next
	}
	addNode.next = node.next
	node.next = &addNode
	ll.size++
	return nil
}

// RemoveAt removes a node at position i
func (ll *UserLinkedList) RemoveAt(i int) (*bean.User, error) {
	ll.lock.Lock()
	defer ll.lock.Unlock()
	if i < 0 || i > ll.size {
		return nil, fmt.Errorf("Index out of bounds")
	}
	node := ll.head
	j := 0
	for j < i-1 {
		j++
		node = node.next
	}
	remove := node.next
	node.next = remove.next
	ll.size--
	return remove.content, nil
}

// RemoveAt removes a node at position i
func (ll *UserLinkedList) Remove(id string) bool {
	ll.lock.Lock()
	defer ll.lock.Unlock()
	node := ll.head
	pre := node
	for {
		if node.content.UserId == id {
			break
		}
		if node.next == nil {
			return false
		}
		pre = node
		node = node.next
	}
	pre.next = node.next
	ll.size--
	return true
}

// IndexOf returns the position of the User t
func (ll *UserLinkedList) IndexOf(t *bean.User) int {
	ll.lock.RLock()
	defer ll.lock.RUnlock()
	node := ll.head
	j := 0
	for {
		if node.content == t {
			return j
		}
		if node.next == nil {
			return -1
		}
		node = node.next
		j++
	}
}

// LookFor returns the User t and bool result
func (ll *UserLinkedList) LookFor(id string) (*bean.User, bool) {
	ll.lock.RLock()
	defer ll.lock.RUnlock()
	node := ll.head
	for {
		if node.content.UserId == id {
			return node.content, true
		}
		if node.next == nil {
			return nil, false
		}
		node = node.next
	}
}

// IsEmpty returns true if the list is empty
func (ll *UserLinkedList) IsEmpty() bool {
	ll.lock.RLock()
	defer ll.lock.RUnlock()
	if ll.head == nil {
		return true
	}
	return false
}

// Size returns the linked list size
func (ll *UserLinkedList) Size() int {
	ll.lock.RLock()
	defer ll.lock.RUnlock()
	size := 0
	last := ll.head
	for {
		if last == nil {
			break
		}
		size++
		if last.next == nil {
			break
		}
		last = last.next
	}
	return size
}

// Insert adds an User at position i
func (ll *UserLinkedList) String() {
	ll.lock.RLock()
	defer ll.lock.RUnlock()
	node := ll.head
	j := 0
	for {
		if node == nil {
			break
		}
		j++
		fmt.Print(node.content)
		fmt.Print(" ")
		node = node.next
	}
	fmt.Println()
}

// Head returns a pointer to the first node of the list
func (ll *UserLinkedList) Head() *Node {
	ll.lock.RLock()
	defer ll.lock.RUnlock()
	return ll.head
}

// Head returns a pointer to the first node of the list
func (node *Node) Next() *Node {
	return node.next
}

// Head returns a pointer to the first node of the list
func (node *Node) Content() *bean.User {
	return node.content
}

// Lock
func (ll *UserLinkedList) Lock() {
	ll.lock.RLock()
}

// RLock
func (ll *UserLinkedList) RLock() {
	ll.lock.RLock()
}

// Unlock
func (ll *UserLinkedList) Unlock() {
	ll.lock.Unlock()
}

// RUnlock
func (ll *UserLinkedList) RUnlock() {
	ll.lock.RUnlock()
}
